#!/usr/bin/env python3
"""
Convert MODULE.bazel git_override to archive_override for faster CI builds.

This script reads MODULE.bazel, converts git_override to archive_override
for tools without submodules, and keeps git_override for tools with submodules.
"""

import re
import sys

def main():
    # Read original MODULE.bazel
    with open('MODULE.bazel', 'r') as f:
        content = f.read()

    # Add header comment
    output = '# rules_hdl MODULE.bazel with archive_override\n'
    output += '# This file is AUTO-GENERATED by CI for production use\n'
    output += '# For development, use the git_override version in MODULE.bazel\n\n'

    # Keep everything before the first git_override
    before_overrides = re.split(r'\n\s*git_override\s*\(', content, 1)[0]
    output += before_overrides + '\n'

    # Find all git_override blocks
    git_override_pattern = r'git_override\s*\(\s*module_name\s*=\s*"([^"]+)"[^)]*commit\s*=\s*"([^"]+)"[^)]*remote\s*=\s*"([^"]+)"[^)]*\)'

    # Tools that have submodules (keep git_override for these)
    tools_with_submodules = {'yosys', 'nextpnr', 'prjtrellis'}

    output += '\n# =============================================================================\n'
    output += '# Override configuration\n'
    output += '# =============================================================================\n\n'

    for match in re.finditer(git_override_pattern, content):
        module_name = match.group(1)
        commit = match.group(2)
        remote = match.group(3)

        # Extract repo path from remote URL
        repo_match = re.search(r'github\.com[:/]([^/]+)/([^/\.]+)', remote)
        if repo_match:
            owner = repo_match.group(1)
            repo = repo_match.group(2)

            if module_name in tools_with_submodules:
                # Keep git_override for tools with submodules
                output += f'# {module_name} has submodules - needs CI-generated release (TODO)\n'
                output += f'git_override(\n'
                output += f'    module_name = "{module_name}",\n'
                output += f'    commit = "{commit}",\n'
                output += f'    init_submodules = True,\n'
                output += f'    remote = "{remote}",\n'
                output += f')\n\n'
            else:
                # Convert to archive_override using GitHub archive URL
                archive_url = f"https://github.com/{owner}/{repo}/archive/{commit}.tar.gz"
                strip_prefix = f"{repo}-{commit}"
                output += f'# {module_name} - direct GitHub archive (no submodules)\n'
                output += f'archive_override(\n'
                output += f'    module_name = "{module_name}",\n'
                output += f'    urls = ["{archive_url}"],\n'
                output += f'    strip_prefix = "{strip_prefix}",\n'
                output += f')\n\n'

    # Handle OpenROAD separately (has git_override in original)
    openroad_pattern = r'git_override\s*\([^)]*module_name\s*=\s*"openroad"[^)]+\)'
    openroad_match = re.search(openroad_pattern, content, re.DOTALL)
    if openroad_match:
        or_commit = re.search(r'commit\s*=\s*"([^"]+)"', openroad_match.group(0))
        or_remote = re.search(r'remote\s*=\s*"([^"]+)"', openroad_match.group(0))
        if or_commit and or_remote:
            or_repo_match = re.search(r'github\.com[:/]([^/]+)/([^/\.]+)', or_remote.group(1))
            if or_repo_match:
                or_owner = or_repo_match.group(1)
                or_repo = or_repo_match.group(2)
                or_archive_url = f"https://github.com/{or_owner}/{or_repo}/archive/{or_commit.group(1)}.tar.gz"
                or_strip = f"{or_repo}-{or_commit.group(1)}"
                output += f'# OpenROAD - convert to archive (has submodules, needs CI release)\n'
                output += f'archive_override(\n'
                output += f'    module_name = "openroad",\n'
                output += f'    urls = ["{or_archive_url}"],\n'
                output += f'    strip_prefix = "{or_strip}",\n'
                output += f')\n\n'

    # Add extensions section from original
    extensions_match = re.search(r'(python\s*=\s*use_extension.*)', content, re.DOTALL)
    if extensions_match:
        output += '# =============================================================================\n'
        output += '# Extensions (preserved from original MODULE.bazel)\n'
        output += '# =============================================================================\n\n'
        output += extensions_match.group(1)

    print(output, end='')

if __name__ == '__main__':
    main()
